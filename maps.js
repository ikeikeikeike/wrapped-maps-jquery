// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['jquery'], function($) {
    /*
      @name          wrapped-maps-jquery
      @description   A jQuery plugin for Google maps api v3.
      @homepage      https://github.com/ikeikeikeike/wrapped-maps-jquery
      @support_url   https://github.com/ikeikeikeike/wrapped-maps-jquery/issues
    */

    /* Main object
    */

    var MAPSMODULE;
    MAPSMODULE = {};
    MAPSMODULE.moduleChecker = function() {
      /* Using modules
      */
      try {
        google.maps.Geocoder;
        google.maps.GeocoderStatus;
        google.maps.DirectionsTravelMode;
        google.maps.DirectionsRenderer;
        google.maps.DirectionsService;
        google.maps.DirectionsStatus;
        google.maps.ControlPosition;
        google.maps.InfoWindow;
        google.maps.LatLng;
        google.maps.Map;
        google.maps.Marker;
        google.maps.MapTypeId;
        google.maps.event;
        jQuery("html");
      } catch (error) {
        console.log("[wrapped-maps-jquery] Required module error: " + error + ", Required module in maps.js.");
        return false;
      }
      return true;
    };
    if (MAPSMODULE.moduleChecker() === false) {
      return MAPSMODULE;
    }
    /* Utility
    */

    String.prototype.capitalize = function() {
      /*
          .. e.g. ::
      
            "hello world".capitalize();  =>  "Hello world"
      */
      return this.charAt(0).toUpperCase() + this.slice(1);
    };
    MAPSMODULE.BaseClass = (function() {

      function BaseClass() {}

      /* Common methods
      */


      /* New object
      */


      BaseClass.prototype.newobj = null;

      BaseClass.prototype.getOptions = function() {
        /* Get options
        */
        return this.options;
      };

      BaseClass.prototype.setOptions = function(objects) {
        /* Set options by objects
        */

        var key, value, _results;
        _results = [];
        for (key in objects) {
          value = objects[key];
          _results.push(this.options[key] = value);
        }
        return _results;
      };

      BaseClass.prototype.getNewobj = function() {
        /* Get new object
        */
        return this.newobj;
      };

      BaseClass.prototype.setNewobj = function(newobj) {
        return this.newobj = newobj;
        /* Set new object
        */

      };

      BaseClass.prototype.setValue = function(value, el) {
        if (el == null) {
          el = this.el;
        }
        /* Set value to a dom
        */

        if (el.is("[type='text'],textarea")) {
          return el.val(value);
        } else {
          return el.text(value);
        }
      };

      BaseClass.prototype.getValue = function(el) {
        if (el == null) {
          el = this.el;
        }
        /* Get value of a dom
        */

        if (el.is("[type='text'],textarea")) {
          return el.val();
        } else {
          return el.text();
        }
      };

      BaseClass.prototype.compute = function(num) {
        /* Compute lat and lng
        */
        return Math.round(num * 1000000000) / 1000000000;
      };

      return BaseClass;

    })();
    MAPSMODULE.Event = (function() {

      function Event() {}

      /* Wrapped
      */


      Event.event = google.maps.event;

      Event.on = function(object, event, callback) {
        /* Event listener
        */
        return MAPSMODULE.Event.event.addListener(object, event, callback);
      };

      return Event;

    })();
    MAPSMODULE.DirectionsStatue = (function() {
      /* Status Errors
      */

      DirectionsStatue.prototype.statues = [];

      function DirectionsStatue(directionsStatus) {
        this.directionsStatus = directionsStatus != null ? directionsStatus : google.maps.DirectionsStatus;
        /* Initializer
        */

        this.statues[this.directionsStatus.INVALID_REQUEST] = 'DirectionsRequest が無効';
        this.statues[this.directionsStatus.MAX_WAYPOINTS_EXCEEDED] = '経由点がが多すぎます。経由点は 8 以内です';
        this.statues[this.directionsStatus.NOT_FOUND] = 'いずれかの点が緯度経度に変換できませんでした';
        this.statues[this.directionsStatus.OVER_QUERY_LIMIT] = '単位時間当りのリクエスト制限回数を超えました';
        this.statues[this.directionsStatus.REQUEST_DENIED] = 'このサイトからはルートサービスを使用できません';
        this.statues[this.directionsStatus.UNKNOWN_ERROR] = '不明なエラーです。もう一度試すと正常に処理される可能性があります';
        this.statues[this.directionsStatus.ZERO_RESULTS] = 'ルートを見つけられませんでした';
      }

      DirectionsStatue.prototype.getMessage = function(status) {
        /* Get status message
        */
        return this.statues[status];
      };

      return DirectionsStatue;

    })();
    MAPSMODULE.DirectionsRenderer = (function(_super) {

      __extends(DirectionsRenderer, _super);

      /* Wrapping class
      */


      /* Render options
      */


      DirectionsRenderer.prototype.options = {
        draggable: true
      };

      function DirectionsRenderer(panelName, options, directionsRenderer) {
        this.panelName = panelName;
        if (options == null) {
          options = null;
        }
        this.directionsRenderer = directionsRenderer != null ? directionsRenderer : google.maps.DirectionsRenderer;
        /* Initializer
        */

        if (options !== null) {
          this.setOptions(options);
        }
        this.setNewobj(new this.directionsRenderer(this.options));
        this.setPanel(this.panelName);
      }

      DirectionsRenderer.prototype.setMap = function(map) {
        /* Set map object.
        */
        return this.getNewobj().setMap(map);
      };

      DirectionsRenderer.prototype.setPanel = function(panelName) {
        if (panelName == null) {
          panelName = this.panelName;
        }
        /* Set panel by element name.
        */

        return this.getNewobj().setPanel(panelName);
      };

      DirectionsRenderer.prototype.setDirections = function(results) {
        /* Set response results of directionsService.route
        */
        return this.getNewobj().setDirections(results);
      };

      return DirectionsRenderer;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.DirectionsService = (function(_super) {

      __extends(DirectionsService, _super);

      /* Wrapping class
      */


      /* Route options
      */


      DirectionsService.prototype.options = {
        origin: '',
        destination: '',
        waypoints: '',
        optimizeWaypoints: true,
        avoidHighways: true,
        avoidTolls: true,
        travelMode: google.maps.DirectionsTravelMode.DRIVING
      };

      function DirectionsService(options, directionsService, status) {
        if (options == null) {
          options = null;
        }
        this.directionsService = directionsService != null ? directionsService : google.maps.DirectionsService;
        this.status = status != null ? status : MAPSMODULE.DirectionsStatue;
        /* Initializer
        */

        if (options !== null) {
          this.setOptions(this.checkOptions(options));
        }
        this.setNewobj(new this.directionsService());
        this.status = new this.status();
      }

      DirectionsService.prototype.checkOptions = function(options) {
        /* Check options
        */

        var d, travelmode;
        travelmode = google.maps.DirectionsTravelMode;
        if (!options.travelMode) {
          options.travelMode = this.options.travelMode;
        } else if (options.travelMode === travelmode.TRANSIT) {
          d = new Date();
          d.setTime(new Date().getTime() + (60 * 60 * 1000));
          options.travelMode = travelmode.TRANSIT;
          options.transitOptions = {
            departureTime: d
          };
          options.unitSystem = google.maps.UnitSystem.IMPERIAL;
        } else if (options.travelMode === travelmode.BICYCLING) {
          console.log("" + travelmode.BICYCLING + " is beta.");
        } else if (options.travelMode === travelmode.WALKING) {
          console.log("" + travelmode.WALKING + " is beta.");
        }
        return options;
      };

      DirectionsService.prototype._route = function(callback, options) {
        var self;
        if (options == null) {
          options = this.options;
        }
        /* Request route
        */

        self = this;
        options = this.checkOptions(options);
        if (this.correspondBetaForTransit(options)) {
          return this.getNewobj().route(options, function(response, status) {
            var message_, st, status_;
            if (status === google.maps.DirectionsStatus.OK) {
              st = {
                status: status,
                message: '',
                bool: true
              };
            } else {
              status_ = "Directions Service Error: " + status;
              message_ = "\n" + (self.status.getMessage(status));
              st = {
                status: status_,
                message: message_,
                bool: false
              };
            }
            return callback(response, st);
          });
        }
      };

      DirectionsService.prototype.route = function(options, callback) {
        if (options == null) {
          options = this.options;
        }
        /* Request route
        */

        return this._route(callback, this.checkOptions(options));
      };

      DirectionsService.prototype.correspondBetaForTransit = function(options) {
        var url, w;
        if (options == null) {
          options = this.options;
        }
        /* For transit
        */

        if (this.options.travelMode === google.maps.DirectionsTravelMode.TRANSIT) {
          if (window.confirm("交通機関は現在Beta版のため提供しているAPIが不完全です\n「OK」を選択すると引続きGoogleMaps上で検索します\n\nhttps://maps.google.comで検索しますか？\n")) {
            url = "https://maps.google.co.jp/maps?saddr=" + options.origin + "&daddr=" + options.destination + "&hl=ja&ie=UTF8&sll=35.706586,139.767723&sspn=0.040633,0.076818&ttype=now&noexp=0&noal=0&sort=def&mra=ltm&t=m&z=13&start=0";
            w = window.open();
            w.location.href = url;
            return false;
          }
        }
        return true;
      };

      return DirectionsService;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.Geocorder = (function(_super) {

      __extends(Geocorder, _super);

      /* Wrapping class
      */


      function Geocorder(geocoder, status) {
        this.geocoder = geocoder != null ? geocoder : google.maps.Geocoder;
        this.status = status != null ? status : google.maps.GeocoderStatus;
        /* Initializer
        */

        this.setNewobj(new this.geocoder());
      }

      Geocorder.prototype.addressToLatlng = function(address, callback) {
        /* Convert from address to latlng
        */

        var _this = this;
        return this.getNewobj().geocode({
          'address': address
        }, function(results, status) {
          var message, prefix;
          _this.setResults(results);
          if (status === _this.status.OK) {
            message = "ok";
          } else {
            prefix = "[Geocorder.addressToLatlng] ";
            message = "Geocode was not successful for the following reason: " + status;
            console.log("" + prefix + " " + message);
            console.log("" + prefix + "Request error: Parameter address is `" + address + "`");
          }
          return callback(results, status, message);
        });
      };

      Geocorder.prototype.setResults = function(results) {
        return this.results = results;
        /* Set result of Geocoder to this object
        */

      };

      Geocorder.prototype.getResults = function() {
        /* Result all
        */
        return this.results;
      };

      Geocorder.prototype.getCurrentLocation = function() {
        /* Current location
        */
        try {
          return this.results[0].geometry.location;
        } catch (e) {
          return console.log("[Geocorder.getCurrentLocation] " + e);
        }
      };

      return Geocorder;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.Geolocation = (function(_super) {

      __extends(Geolocation, _super);

      /* Wrapped geo
      */


      Geolocation.prototype.result = null;

      Geolocation.prototype.options = {
        maximumAge: 0,
        timeout: 2000,
        enableHighAccuracy: true
      };

      function Geolocation(options, geolocation) {
        if (options == null) {
          options = null;
        }
        this.geolocation = geolocation != null ? geolocation : this.getGeo();
        /* Initializer
        */

        if (options !== null) {
          this.setOptions(options);
        }
      }

      Geolocation.prototype.checkGeo = function() {
        /* Checker
        */
        if (navigator.geolocation) {
          return true;
        } else {
          return false;
        }
      };

      Geolocation.prototype.getResult = function() {
        /*
        */
        return this.result;
      };

      Geolocation.prototype.setResult = function(result) {
        return this.result = result;
        /*
        */

      };

      Geolocation.prototype.getGeo = function() {
        /* Getter
        */
        if (this.checkGeo()) {
          return navigator.geolocation;
        } else {
          return null;
        }
      };

      Geolocation.prototype.getCurrentLocation = function(callback) {
        /* Using watchPosition api.
        
        @param {Function} callback
        
        .. note ::
        
            Using watchPosition api.
        */

        var WAIT, calcs, self, watchId;
        if (this.checkGeo() === false) {
          console.log("[Geolocation.getCurrentLocation] Location error: Disabled navigator.geolocation.");
          return false;
        }
        self = this;
        calcs = [];
        WAIT = 3000;
        watchId = this.getGeo().watchPosition(function(position) {
          return calcs.push({
            success: position
          });
        }, function(error) {
          return calcs.push({
            error: error
          });
        }, this.getOptions());
        return setTimeout(function() {
          var r;
          self.getGeo().clearWatch(watchId);
          r = self.calcLocation(calcs);
          return callback(r, r.status);
        }, WAIT);
      };

      Geolocation.prototype.calcLocation = function(calcs) {
        /* Calculate position object
        
        @param {Array<Object>} calcs
        @return {Object}
        */

        var calc, r, _i, _len;
        r = {
          code: 1000,
          status: false,
          coords: {
            accuracy: 1000
          }
        };
        for (_i = 0, _len = calcs.length; _i < _len; _i++) {
          calc = calcs[_i];
          if (calc.success) {
            if (calc.success.coords.accuracy < r.coords.accuracy) {
              r = calc.success;
              r.status = true;
            }
          } else if (r.status === false) {
            r = calc.error;
            r.status = false;
            r.coords = {
              accuracy: 1000
            };
          }
        }
        this.setResult(r);
        return r;
      };

      return Geolocation;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.Marker = (function(_super) {

      __extends(Marker, _super);

      /* Wrapping class
      */


      /* Marker options
      */


      Marker.prototype.options = {
        position: null,
        map: null,
        title: null
      };

      function Marker(options, marker) {
        this.options = options;
        this.marker = marker != null ? marker : google.maps.Marker;
        /* Initializer
        */

        this.setNewobj(this.getNew());
      }

      Marker.prototype.getNew = function(options) {
        if (options == null) {
          options = this.options;
        }
        /* Get new object
        */

        return new this.marker(options);
      };

      return Marker;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.InfoWindow = (function(_super) {

      __extends(InfoWindow, _super);

      /* Wrapping class
      */


      InfoWindow.prototype.el = null;

      InfoWindow.prototype.options = {
        elName: '#info_window',
        map: null,
        marker: null,
        title: null,
        body: null
      };

      InfoWindow.prototype.defaultTemplate = "<div class=\"\">\n  <div class=\"modal-header modal-header-wrapper\">\n    <h3>{title}</h3>\n  </div>\n  <div class=\"modal-body\">\n    <span>{body}</span>\n  </div>\n</div>";

      function InfoWindow(options, infowindow) {
        if (options == null) {
          options = null;
        }
        this.infowindow = infowindow != null ? infowindow : google.maps.InfoWindow;
        /* Initializer
        */

        this.el = options.elName ? $(options.elName) : $('');
        if (options !== null) {
          this.setOptions(options);
        }
        this.setNewobj(this.getNew());
      }

      InfoWindow.prototype.getNew = function() {
        /* Get new object
        */
        return new this.infowindow();
      };

      InfoWindow.prototype.getContent = function(title, body) {
        /*
        */

        var newinfo;
        newinfo = this.getNewobj() || this.getNew();
        newinfo.setContent(this.renderTemplate(title, body));
        return newinfo;
      };

      InfoWindow.prototype.getTemplate = function() {
        /* Get default template or specific element
        */
        if (this.el.is('*')) {
          return this.el.html();
        } else {
          return this.defaultTemplate;
        }
      };

      InfoWindow.prototype.renderTemplate = function(title, body) {
        var t, _ref, _ref1;
        if (title == null) {
          title = null;
        }
        if (body == null) {
          body = null;
        }
        /*
        */

        t = this.getTemplate();
        t = t.replace('{title}', title || ((_ref = this.options) != null ? _ref.title : void 0));
        t = t.replace('{body}', body || ((_ref1 = this.options) != null ? _ref1.body : void 0));
        return t;
      };

      InfoWindow.prototype.open = function(title, body, map, marker) {
        var info;
        if (map == null) {
          map = this.options.map;
        }
        if (marker == null) {
          marker = this.options.marker;
        }
        /* Open info window
        */

        info = this.getContent(title, body);
        info.open(map, marker);
        return info;
      };

      return InfoWindow;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.Map = (function(_super) {

      __extends(Map, _super);

      /* Wrapped
      */


      /* Render element selector
      */


      Map.prototype.el = null;

      /* Renderer options
      */


      Map.prototype.options = {
        zoom: 14,
        scrollwheel: false,
        scaleControl: true,
        center: null,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        scaleControlOptions: {
          position: google.maps.ControlPosition.BOTTOM_CENTER
        }
      };

      function Map(elName, options, map) {
        this.elName = elName != null ? elName : '#googlemaps';
        if (options == null) {
          options = null;
        }
        this.map = map != null ? map : google.maps.Map;
        /* Initializer
        */

        this.el = $(this.elName);
        if (options !== null) {
          this.setOptions(options);
        }
        this.setNewobj(this.getNew());
        this.checkOptions();
      }

      Map.prototype.checkOptions = function() {
        /* Checking option
        */
        if (!this.options.center) {
          console.log("[MAP.checkOptions] Option error: options.center is " + this.options.center);
        }
        if (!this.options.zoom) {
          return console.log("[MAP.checkOptions] Option error: options.zoom is " + this.options.zoom);
        }
      };

      Map.prototype.getNewobj = function() {
        /* Get newobj
        */
        this.checkOptions();
        return this.newobj;
      };

      Map.prototype.setCenter = function(latlng) {
        /* Google latlng object
        */
        this.setOptions({
          center: latlng
        });
        this.getNewobj().setCenter(latlng);
        return this.checkOptions();
      };

      Map.prototype.getNew = function(el, options) {
        if (el == null) {
          el = this.el;
        }
        if (options == null) {
          options = this.options;
        }
        /* Get new map object
        */

        return new this.map(el.get(0), options);
      };

      Map.prototype.getAddress = function() {
        /* Address
        */
        return this.el.attr('address');
      };

      Map.prototype.getTitle = function() {
        /* Title
        */
        return this.el.attr('title');
      };

      Map.prototype.getBody = function() {
        /* Title
        */
        return this.el.attr('body');
      };

      Map.prototype.getContent = function() {
        /* Content
        */
        return this.el.attr('content');
      };

      return Map;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.RouteInfoPanel = (function(_super) {

      __extends(RouteInfoPanel, _super);

      /* Route infomation panel
      */


      /* TOP element
      */


      RouteInfoPanel.prototype.el = null;

      function RouteInfoPanel(elName) {
        this.elName = elName != null ? elName : '#info_panel';
        /* Initializer
        */

        this.el = $(this.elName);
      }

      RouteInfoPanel.prototype.setTotalDistance = function(results, object) {
        /* Set total distance
        */

        var data, overview_path, routes, _i, _j, _len, _len1, _ref, _ref1;
        data = '';
        _ref = results.routes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          routes = _ref[_i];
          _ref1 = routes.overview_path;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            overview_path = _ref1[_j];
            data += "" + (this.compute(overview_path.lng())) + "," + (this.compute(overview_path.lat())) + "\n";
          }
        }
        return this.setValue(data);
      };

      return RouteInfoPanel;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.RouteDirectionsPanel = (function(_super) {

      __extends(RouteDirectionsPanel, _super);

      /* Route result panel
      */


      /* TOP element
      */


      RouteDirectionsPanel.prototype.el = null;

      /* Rirections options
      */


      RouteDirectionsPanel.prototype.options = {
        total: '#total'
      };

      function RouteDirectionsPanel(elName, options) {
        this.elName = elName != null ? elName : '#directions_panel';
        if (options == null) {
          options = null;
        }
        /* Initializer
        @param {String} elName - Top element name.
        @param {Object} options - options.
        
        .. Options, e.g. ::
        
            options =
              total: '#total'
        */

        this.el = $(this.elName);
      }

      RouteDirectionsPanel.prototype.setTotalDistance = function(results, object) {
        /* Set total distance
        */

        var legs, total, _i, _len, _ref;
        total = 0;
        _ref = results.routes[0].legs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          legs = _ref[_i];
          total += legs.distance.value;
        }
        return this.el.find(this.options.total).text(total / 1000 + " km");
      };

      return RouteDirectionsPanel;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.RouteControlPanel = (function(_super) {

      __extends(RouteControlPanel, _super);

      /* Route controller panel
      */


      /* TOP element
      */


      RouteControlPanel.prototype.el = null;

      /* Controller options
      */


      RouteControlPanel.prototype.options = {
        focus: {
          input: true,
          value: true,
          next: true
        },
        start: {
          point: '#start_point',
          checked: '#start_checked'
        },
        end: {
          point: '#end_point',
          checked: '#end_checked'
        },
        way: {
          point: '#way_point',
          checked: '#way_checked',
          nontollway: '#way_nontollway',
          nonhighway: '#way_nonhighway'
        },
        tab: {
          direct: '#tab_direct',
          route: '#tab_route',
          show: '#tab_show',
          hide: '#tab_hide',
          near: '#tab_near',
          info: '#tab_info'
        },
        travelmode: {
          group: '#travelmode-group'
        },
        erralert: '#erralert',
        event: {
          current: {
            id: '.click_current',
            event: {
              click: function(event, cls) {}
            }
          },
          route: {
            id: '#click_route',
            event: {
              click: function(event, cls) {}
            }
          },
          clearaddr: {
            id: '#click_clearaddr',
            event: {
              click: function(event, cls) {}
            }
          }
        }
      };

      function RouteControlPanel(elName, options) {
        this.elName = elName != null ? elName : '#control_panel';
        if (options == null) {
          options = null;
        }
        this.onRoute = __bind(this.onRoute, this);

        this.onClearaddr = __bind(this.onClearaddr, this);

        this.onCurrent = __bind(this.onCurrent, this);

        this.hideError = __bind(this.hideError, this);

        this.showError = __bind(this.showError, this);

        /* Initializer
        @param {String} elName - Top element name.
        @param {Object} options - Contoller options.
        
        .. Options, e.g. ::
        
            options:
              focus:
                input: yes
                value: yes
                next: yes
              start:
                point: '#start_point'
                checked: '#start_checked'
              end:
                point: '#end_point'
                checked: '#end_checked'
              way:
                point: '#way_point'
                checked: '#way_checked'
                nontollway: '#way_nontollway'
                nonhighway: '#way_nonhighway'
              tab:
                direct: '#tab_direct'
                route: '#tab_route'
                info: '#tab_info'
                show: '#tab_show'
                hide: '#tab_hide'
              travelmode:
                group: '#travelmode-group'
                # drive:
                # bicycle: ''
                # transit: ''
                # walk: ''
              erralert: '#erralert'
              # event:
                # route: '#click_route'
                # clearaddr: '#click_clearaddr'
              event:
                current:
                  id: '.click_current'
                  event:
                    click: (event, cls) ->
                route:
                  id: '#click_route'
                  event:
                    click: (event, cls) ->
                clearaddr:
                  id: '#click_clearaddr'
                  event:
                    click: (event, cls) ->
                    dblclick: (event, cls) -> # TODO: Multiple event, Not implemention.
        */

        this.el = $(this.elName);
        this.setSelectors(options || this.options);
        if (this.options.focus.value === true) {
          this.pushValue();
        }
        if (this.options.focus.input === true) {
          this.focusInput();
        }
        this.tabPanel();
      }

      RouteControlPanel.prototype.tabPanel = function() {
        /* Event listener
        */

        var op, self;
        self = this;
        op = this.getOptions();
        $(op.tab.show).on('click', function() {
          $(op.tab.show).addClass("hide");
          return $(self.elName).removeClass("hide");
        });
        return $(op.tab.hide).on('click', function() {
          $(self.elName).addClass("hide");
          return $(op.tab.show).removeClass("hide");
        });
      };

      RouteControlPanel.prototype.setSelectors = function(selectors) {
        /* Controller selectors
        */

        var end, start, way;
        start = selectors != null ? selectors.start : void 0;
        start.checked;
        start.point;
        end = selectors != null ? selectors.end : void 0;
        end.checked;
        end.point;
        way = selectors != null ? selectors.way : void 0;
        way.checked;
        return way.point;
      };

      RouteControlPanel.prototype.generateHtml = function(selectors) {
        /* Generate control panel
        */

      };

      RouteControlPanel.prototype.getSelector = function(key) {
        var i, op, _i, _len, _ref;
        op = this.options;
        _ref = key.split(".");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          op = op[i];
        }
        return op;
      };

      RouteControlPanel.prototype.getElement = function(key) {
        /*
        */
        return $(this.getSelector(key));
      };

      RouteControlPanel.prototype.setValue = function(key, value) {
        /* Set value to a panel
        */
        return RouteControlPanel.__super__.setValue.call(this, value, this.getElement(key));
      };

      RouteControlPanel.prototype.getValue = function(key) {
        /* Get value of a panel
        */
        return RouteControlPanel.__super__.getValue.call(this, this.getElement(key));
      };

      RouteControlPanel.prototype.setValueTostart = function(value) {
        /*
        */
        return this.setValue('start.point', value);
      };

      RouteControlPanel.prototype.setValueToend = function(value) {
        /*
        */
        return this.setValue('end.point', value);
      };

      RouteControlPanel.prototype.setValueToway = function(value) {
        /*
        */
        return this.setValue('way.point', "" + (this.getValue('way.point')) + value + "\n");
      };

      RouteControlPanel.prototype.setPoint = function(latlng, object) {
        if (object == null) {
          object = null;
        }
        /* Set latLng to dom and next focus.
        */

        if (this.isChecked('start.checked')) {
          this.setValueTostart(latlng);
          return this.nextFocus('start.point');
        } else if (this.isChecked('end.checked')) {
          this.setValueToend(latlng);
          return this.nextFocus('end.point');
        } else if (this.isChecked('way.checked')) {
          this.setValueToway(latlng);
          return this.scrollBottom('way.point');
        } else {
          return console.log('[RouteControlPanel.setPoint] Not checked error.');
        }
      };

      RouteControlPanel.prototype.isChecked = function(key) {
        /* Check push value element
        */

        var elm;
        elm = this.getElement(key);
        if (elm.attr('checked')) {
          return true;
        } else if (this._pushValueEl === null) {
          return false;
        } else if (this._pushValueEl.is(elm)) {
          return true;
        } else {
          return false;
        }
      };

      RouteControlPanel.prototype.scrollBottom = function(key) {
        /* Scroller
        */

        var w;
        w = this.getElement(key);
        return w.scrollTop(w.prop('scrollHeight'));
      };

      RouteControlPanel.prototype.showDirectTab = function() {
        /* Show tabs
        */
        return this.showTab(this.options.tab.direct);
      };

      RouteControlPanel.prototype.showControlTab = function() {
        /* Show tabs
        */
        return this.showTab(this.options.tab.route);
      };

      RouteControlPanel.prototype.showTab = function(anchor) {
        /* Show tabs
        */

        var $tab;
        $tab = $("[data-toggle='tab'][href='" + anchor + "']");
        $.Event("click").preventDefault();
        return $tab.click();
      };

      /* Current fucus element
      */


      RouteControlPanel.prototype._pushValueEl = null;

      RouteControlPanel.prototype.nextFocus = function(key) {
        /* Next focus for input text
        */

        var self;
        self = this;
        if (this.options.focus.next) {
          this.getElement(key === "start.point" ? "end.checked" : key === "end.point" ? "way.checked" : void 0).attr('checked', true);
          return this.getElement(key === "start.point" ? "end.point" : key === "end.point" ? "way.point" : void 0).focus(function() {
            return self._pushValueEl = $(this);
          });
        }
      };

      RouteControlPanel.prototype.pushValue = function() {
        /* Set current focus
        */

        var self;
        self = this;
        this.getElement('start.point').focus(function() {
          return self._pushValueEl = $(this);
        }).blur(function() {
          return self._pushValueEl = null;
        });
        this.getElement('end.point').focus(function() {
          return self._pushValueEl = $(this);
        }).blur(function() {
          return self._pushValueEl = null;
        });
        return this.getElement('way.point').focus(function() {
          return self._pushValueEl = $(this);
        }).blur(function() {
          return self._pushValueEl = null;
        });
      };

      RouteControlPanel.prototype.focusInput = function() {
        /* Set current focus
        */

        var self;
        self = this;
        this.getElement('start.point').focus(function() {
          return self.getElement('start.checked').attr('checked', true);
        });
        this.getElement('end.point').focus(function() {
          return self.getElement('end.checked').attr('checked', true);
        });
        return this.getElement('way.point').focus(function() {
          return self.getElement('way.checked').attr('checked', true);
        });
      };

      RouteControlPanel.prototype._getObjkey = function(object) {
        /* For one object
        */

        var k, v;
        return ((function() {
          var _results;
          _results = [];
          for (k in object) {
            v = object[k];
            _results.push(k);
          }
          return _results;
        })())[0];
      };

      RouteControlPanel.prototype._getObjvalue = function(object) {
        /* For one object
        */

        var k, v;
        return ((function() {
          var _results;
          _results = [];
          for (k in object) {
            v = object[k];
            _results.push(v);
          }
          return _results;
        })())[0];
      };

      RouteControlPanel.prototype.on = function(object) {
        if (object == null) {
          object = null;
        }
        /* Utility
        */

        return $(object.id).on(object.event, {
          maincallback: object.callback.main,
          usercallback: object.callback.user
        }, object.method);
      };

      RouteControlPanel.prototype.addEvent = function(key, callback, event) {
        var obj;
        if (event == null) {
          event = this.options.event;
        }
        /* Common
        */

        if (!event) {
          return this.on({
            id: event[key],
            event: 'click',
            method: this["on" + (key.capitalize())],
            callback: {
              main: callback,
              user: null
            }
          });
        } else {
          obj = event[key];
          return this.on({
            id: obj.id,
            event: this._getObjkey(obj.event),
            method: this["on" + (key.capitalize())],
            callback: {
              main: callback,
              user: this._getObjvalue(obj.event)
            }
          });
        }
      };

      RouteControlPanel.prototype.addCurrentEvent = function(callback) {
        /* Add events listener
        */
        return this.addEvent('current', callback);
      };

      RouteControlPanel.prototype.addRouteEvent = function(callback) {
        /* Add events listener
        */
        return this.addEvent('route', callback);
      };

      RouteControlPanel.prototype.addClearaddrEvent = function(callback) {
        /* Add events listener
        */
        return this.addEvent('clearaddr', callback);
      };

      RouteControlPanel.prototype.getTravelmode = function() {
        /* Get travelmode
        */
        return this.getElement('travelmode.group').find('.active').val();
      };

      RouteControlPanel.prototype.showError = function(message, status) {
        /* Show message
        */

        var alt;
        alt = this.getElement('erralert');
        alt.find('strong').text(status);
        alt.find('span').text(message);
        alt.show();
        return alt.find('.close').off("click").on("click", function(e) {
          return $(this).parent().hide();
        });
      };

      RouteControlPanel.prototype.hideError = function() {
        /* Hide message
        */

        var alt;
        alt = this.getElement('erralert');
        alt.find('strong').text('');
        alt.find('span').text('');
        return alt.hide();
      };

      RouteControlPanel.prototype.getCurrentElement = function() {
        /* Get element of current location button
        */
        return $('.tab-pane.active').find("" + this.options.event.current.id);
      };

      RouteControlPanel.prototype.onCurrent = function(event) {
        /* Enabled navigator.geolocation
        */

        var boolean, btn, _ref, _ref1;
        btn = this.getCurrentElement();
        boolean = btn.hasClass("active") ? false : true;
        btn.parents(".controls").find('[type="text"]').attr('disabled', boolean);
        this._addParamsToEvent(event, {
          current: {
            disabled: boolean
          }
        });
        if ((_ref = event.data) != null) {
          _ref.usercallback(event, this);
        }
        return (_ref1 = event.data) != null ? _ref1.maincallback(event, this) : void 0;
      };

      RouteControlPanel.prototype.onClearaddr = function(event) {
        /* Clear form
        */

        var _ref, _ref1;
        this.setValue('start.point', '');
        this.setValue('end.point', '');
        this.setValue('way.point', '');
        this.getElement('start.checked').attr('checked', true);
        this.getElement('way.nonhighway').attr('checked', false);
        this.getElement('way.nontollway').attr('checked', false);
        if ((_ref = event.data) != null) {
          _ref.usercallback(event, this);
        }
        return (_ref1 = event.data) != null ? _ref1.maincallback(event, this) : void 0;
      };

      RouteControlPanel.prototype.onRoute = function(event) {
        /* Route search request
        */

        var end, hw, mode, start, toll, wats, waypts, _i, _len, _ref, _ref1, _ref2;
        if (this.getCurrentElement().hasClass("active")) {
          start = this.getCurrentElement().val();
        } else {
          start = this.getValue('start.point');
        }
        end = this.getValue('end.point');
        hw = this.getElement("way.nonhighway").attr('checked') ? true : false;
        toll = this.getElement("way.nontollway").attr('checked') ? true : false;
        mode = this.getTravelmode();
        waypts = [];
        _ref = this.getValue("way.point").split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          wats = _ref[_i];
          if (wats !== '') {
            waypts.push({
              location: wats,
              stopover: true
            });
          }
        }
        this._addParamsToEvent(event, {
          options: {
            start: start,
            end: end,
            hw: hw,
            toll: toll,
            mode: mode,
            waypts: waypts
          }
        });
        if ((_ref1 = event.data) != null) {
          _ref1.usercallback(event, this);
        }
        return (_ref2 = event.data) != null ? _ref2.maincallback(event, this) : void 0;
      };

      RouteControlPanel.prototype._addParamsToEvent = function(event, params) {
        /*
        */

        var key, value, _base, _results;
        (_base = event.data).controlPanel || (_base.controlPanel = {});
        _results = [];
        for (key in params) {
          value = params[key];
          _results.push(event.data.controlPanel[key] = value);
        }
        return _results;
      };

      return RouteControlPanel;

    })(MAPSMODULE.BaseClass);
    MAPSMODULE.RenderRouteMap = (function(_super) {

      __extends(RenderRouteMap, _super);

      /* Route map class
      */


      /* Control panel
      */


      RenderRouteMap.prototype.controlPanel = MAPSMODULE.RouteControlPanel;

      /* Result panel
      */


      RenderRouteMap.prototype.directPanel = MAPSMODULE.RouteDirectionsPanel;

      /* Info panel
      */


      RenderRouteMap.prototype.infoPanel = MAPSMODULE.RouteInfoPanel;

      /* Direction Renderer object
      */


      RenderRouteMap.prototype.directRender = MAPSMODULE.DirectionsRenderer;

      /* Direction Service object
      */


      RenderRouteMap.prototype.directService = MAPSMODULE.DirectionsService;

      /* Map object
      */


      RenderRouteMap.prototype.map = MAPSMODULE.Map;

      /* Marker object
      */


      RenderRouteMap.prototype.marker = MAPSMODULE.Marker;

      /* InfoWindow object
      */


      RenderRouteMap.prototype.infowindow = MAPSMODULE.InfoWindow;

      /* Event object
      */


      RenderRouteMap.prototype.event = MAPSMODULE.Event;

      /* Geocorder object
      */


      RenderRouteMap.prototype.geocorder = MAPSMODULE.Geocorder;

      /* Geolocation object
      */


      RenderRouteMap.prototype.geolocation = MAPSMODULE.Geolocation;

      function RenderRouteMap(options) {
        if (options == null) {
          options = null;
        }
        /* Initializer
        @param {String|Object} place - Address{String} or Google latlng{Object}.
        @param {Object} options - Options for rendering map.
        
        .. Options, e.g. ::
        
            options =
              directPanel:
                obj: new RouteDirectionsPanel("#directions_panel")
                name: '#directions_panel'
                options: null
              controlPanel:
                obj: new RouteControlPanel("#control_panel")
                name: '#direct_panel'
                options: {}
              infoPanel:
                obj: new RouteInfoPanel("#info_panel")
                name: '#info_panel'
                options: {}
              directRender:
                obj: new DirectionsRenderer('#renderer')
                name: '#renderer'
                options: {}
              map:
                obj: new Map("#map")
                name: '#map'
                options: {}
        */

        this.setOptionClass(options, 'directPanel');
        this.setOptionClass(options, 'controlPanel');
        this.setOptionClass(options, 'infoPanel');
        this.setOptionClass(options, 'directRender');
        this.setOptionClass(options, 'map');
        this.setOptionClass(options, 'geocorder');
        this.setOptionClass(options, 'geolocation');
        this.place = options != null ? options.place : void 0;
      }

      RenderRouteMap.prototype.setOptionClass = function(options, key) {
        /* Set class to property
        */

        var name, objs, objsObj, v;
        objs = options != null ? options[key] : void 0;
        objsObj = (objs != null ? objs.obj : void 0) || null;
        if (objsObj !== null) {
          return this[key] = objsObj;
        } else {
          name = (objs != null ? objs.name : void 0) || null;
          if (name === null) {
            console.log("[RenderRouteMap.constructor] Arguments warning: options." + key + ".name is require. (" + key + ".name is " + name + ")");
          }
          return this[key] = new (((function() {
            var _results;
            _results = [];
            for (v in objs != null ? objs.options : void 0) {
              _results.push(v);
            }
            return _results;
          })()).length ? this[key](name, objs.options) : name ? this[key](name) : this[key]);
        }
      };

      RenderRouteMap.prototype.getLatlng = function(place, callback) {
        if (place == null) {
          place = this.place;
        }
        /* Get latlng
        */

        return this.geocorder.addressToLatlng(place || this.map.getAddress(), function(results, status, message) {
          return callback(results, status, message);
        });
      };

      RenderRouteMap.prototype.getMarker = function(latlng, title, map) {
        if (title == null) {
          title = this.map.getTitle();
        }
        if (map == null) {
          map = this.map.getNewobj();
        }
        /* Get marker object
        */

        return new this.marker({
          position: latlng,
          title: title,
          map: map
        });
      };

      RenderRouteMap.prototype.getInfowindow = function(marker, title, map) {
        if (title == null) {
          title = this.map.getTitle();
        }
        if (map == null) {
          map = this.map.getNewobj();
        }
        /* Open info window
        */

        marker = (marker != null ? marker.getNewobj() : void 0) || marker;
        return new this.infowindow({
          marker: marker,
          map: map,
          title: title
        });
      };

      RenderRouteMap.prototype.openInfowindow = function(marker, title, body) {
        var infowindow;
        if (title == null) {
          title = this.map.getTitle();
        }
        if (body == null) {
          body = this.map.getBody();
        }
        /*
        */

        infowindow = this.getInfowindow(marker);
        infowindow.open(title, body);
        return infowindow;
      };

      RenderRouteMap.prototype.setMap = function(map) {
        if (map == null) {
          map = this.map.getNewobj();
        }
        /* Set map
        */

        return this.directRender.setMap(map);
      };

      RenderRouteMap.prototype.setDirectPanel = function(directPanelEl) {
        if (directPanelEl == null) {
          directPanelEl = this.directPanel.el;
        }
        /* Set panel
        */

        if (directPanelEl.is('*')) {
          return this.directRender.setPanel(directPanelEl.get(0));
        } else {
          return console.log("[RenderRouteMap.setDirectPanel] Arguments error: (directPanelEl is " + directPanelEl + ")");
        }
      };

      RenderRouteMap.prototype.run = function(options) {
        var _this = this;
        if (options == null) {
          options = {};
        }
        /* Render map
        */

        return this.getLatlng(options != null ? options.place : void 0, function(results, status, message) {
          /* Current latlng
          */

          var infowindow, marker, _setCurrentLocation;
          _this.map.setCenter(_this.geocorder.getCurrentLocation());
          _this.setMap();
          _this.setDirectPanel();
          marker = _this.getMarker(_this.geocorder.getCurrentLocation());
          infowindow = _this.openInfowindow(marker);
          /* Event receivers
          */

          _setCurrentLocation = function() {
            return _this.geolocation.getCurrentLocation(function(result, status) {
              var btn, w;
              if (status === true) {
                btn = _this.controlPanel.getCurrentElement();
                return btn.val("(" + result.coords.latitude + ", " + result.coords.longitude + ")");
              } else if (result.code === 1) {
                console.log("[RenderRouteMap.run] Current location error: code " + result.code + ", " + result.message);
                if (window.confirm("現在位置情報が設定により取得できなくなっています\n現在位置を使用する場合は、設定より位置情報を許可して下さい\n\n許可設定のヘルプを確認しますか？")) {
                  w = window.open();
                  return w.location.href = '/';
                }
              } else if (result.code === 1000) {
                /* Tail recursion
                */

                console.log("[RenderRouteMap.run] Warning: tail recursion. " + status + result);
                return _setCurrentLocation();
              }
            });
          };
          _this.controlPanel.addCurrentEvent(function(event, cls) {
            /* On submit location current .
            */
            if (event.data.controlPanel.current.disabled === true) {
              return _setCurrentLocation();
            }
          });
          _this.controlPanel.addClearaddrEvent(function(event, cls) {
            /* On submit clear input values.
            */

          });
          _this.controlPanel.addRouteEvent(function(event, cls) {
            /* On submit route search
            */

            var service;
            options = event.data.controlPanel.options;
            service = new _this.directService({
              origin: options.start,
              destination: options.end,
              waypoints: options.waypts,
              optimizeWaypoints: true,
              avoidHighways: options.hw,
              avoidTolls: options.toll,
              travelMode: options.mode
            });
            return service._route(function(response, status) {
              /* Request calc route
              */
              if (status.bool === true) {
                _this.controlPanel.showDirectTab();
                _this.directRender.setDirections(response);
                _this.infoPanel.setTotalDistance(response);
                return _this.controlPanel.hideError();
              } else {
                return _this.controlPanel.showError(status.message, status.status);
              }
            });
          });
          _this.event.on(marker.getNewobj(), 'click', function(event) {
            /* Mouse event receiver
            */
            return _this.openInfowindow(marker);
          });
          _this.event.on(_this.map.getNewobj(), 'click', function(event) {
            /* Mouse event receiver
            */
            _this.controlPanel.showControlTab();
            return _this.controlPanel.setPoint(event.latLng, _this.map.getNewobj());
          });
          return _this.event.on(_this.directRender.getNewobj(), 'click', function(event) {
            /* Directions changed event receiver
            */

            var newobj;
            newobj = _this.directRender.getNewobj();
            _this.directPanel.setTotalDistance(newobj.directions, newobj);
            return _this.infoPanel.setTotalDistance(newobj.directions, newobj);
          });
        });
      };

      return RenderRouteMap;

    })(MAPSMODULE.BaseClass);
    return MAPSMODULE;
  });

}).call(this);
